
types represent computation

tic tac toe > min max > 5 in a row > monte carlo > go > mind ninja
    perhaps add some probability stuff at some point
    try HLearn

the attractive thing about computing has always been trying to encode
some kind of human though ...
    articles say it fails
    but ... how about trying it for yourself first ...
    like ... how does a person decide where to play?
    they come up with reasons for things .. and you could try to
    encode this reasoning process? heuristics etc...
    could help with improving your own reasoning too perahps
    making it more conscious i mean

2048 to fit in somehow

how about busy beaver as another haskell practice thing?
https://www.scottaaronson.com/writings/bignumbers.html

other graph theory stuff?

haskell trip ups
    operator precendence
    compiler error messages
    types
    indentation

-- functional means everything is an expression, everything does nothing but return a value
-- chain these functions(expressions, same thing(?)) together

-- a for loop is the same as mapping a function over a list
  -- function corresponds to loop body given the argument of loop iteration variable
  -- list corresponds to all traversed values of the iteration variable
  
  -- use a list comprehension to create the list ..

-- why does it feel like i'm thinking backwards with haskell? kind of like end result to beginning rather than start
-- [direction] > [[2 directions] > [[Int Int]] > [Int] > Bool
-- ... could be simpler .. use one map for the 2nd and 3rd expression transform
-- endp board row col =
--  if board !! row !! col then False else
--    any (== 3) . map length . [[0, 1], [1, 1], [1, 0], [1, -1]]
--      where length dir = sum . map (count 1) [map (* (-1)) dir, dir]
--            count c [dr, dc] = undefined

-- maybe just type backwards ... go up?

-- **** how can i apply multiple predicates to the same data and everything together ... good pattern ..***
  -- valid nr nc and stuff ...
  -- use lists again .. somehow ... omfg

-- backwards .. seemingly .. but actually .. high level is higher, low level is lower ... omfg.
-- HIGHER LEVEL in HIGHER LINES, LOWER LEVEL in LOWER LINES


-- anonymous recursive function .. import fix from Data.fix .. fix f = f (fix f) .. wtf.

-- you could make all arguments lists of related stuff to map things homogenously to
-- oh my ... less need for your own type and data constructor then



-- get board coord = board !! (coord !! 0) !! (coord !! 1)

data Matrix a = Cell a | Nested (Matrix [a])

get :: Num a => Matrix a -> [a] -> a
get (Nested (Nested space)) (dim:dims) = if null dims then val else get val dims where val = space !! dim

main = do
  print "hi"

