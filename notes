

-- operator precendence ... hard in haskell ... easy in lisp

-- functional means everything is an expression, everything does nothing but return a value
-- chain these functions(expressions, same thing(?)) together

-- a for loop is the same as mapping a function over a list
  -- function corresponds to loop body given the argument of loop iteration variable
  -- list corresponds to all traversed values of the iteration variable
  
  -- use a list comprehension to create the list ..

-- why does it feel like i'm thinking backwards with haskell? kind of like end result to beginning rather than start
-- [direction] > [[2 directions] > [[Int Int]] > [Int] > Bool
-- ... could be simpler .. use one map for the 2nd and 3rd expression transform
-- endp board row col =
--  if board !! row !! col then False else
--    any (== 3) . map length . [[0, 1], [1, 1], [1, 0], [1, -1]]
--      where length dir = sum . map (count 1) [map (* (-1)) dir, dir]
--            count c [dr, dc] = undefined

-- maybe just type backwards ... go up?



-- **** how can i apply multiple predicates to the same data and everything together ... good pattern ..***
  -- valid nr nc and stuff ...
  -- use lists again .. somehow ... omfg

-- backwards .. seemingly .. but actually .. high level is higher, low level is lower ... omfg.
-- HIGHER LEVEL in HIGHER LINES, LOWER LEVEL in LOWER LINES


-- anonymous recursive function .. import fix from Data.fix .. fix f = f (fix f) .. wtf.

-- you could make all arguments lists of related stuff to map things homogenously to
-- oh my ... less need for your own type and data constructor then



-- get board coord = board !! (coord !! 0) !! (coord !! 1)

data Matrix a = Cell a | Nested (Matrix [a])

get :: Num a => Matrix a -> [a] -> a
get (Nested (Nested space)) (dim:dims) = if null dims then val else get val dims where val = space !! dim

main = do
  print "hi"

